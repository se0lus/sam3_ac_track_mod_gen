"""Stage 7: Generate virtual wall data using mask contours + Gemini AI."""
from __future__ import annotations

import argparse
import json
import logging
import os
import sys

logger = logging.getLogger("sam3_pipeline.s07")

_script_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if _script_dir not in sys.path:
    sys.path.insert(0, _script_dir)

from pipeline_config import PipelineConfig


def run(config: PipelineConfig) -> None:
    """Execute Stage 7: AI wall generation.

    Reads modelscale image from ``config.mask_full_map_dir`` (stage 2 output),
    uses trees/grass masks for precise wall placement,
    writes walls JSON + preview to ``config.stage_dir("ai_walls")``.
    """
    logger.info("=== Stage 7: AI wall generation ===")

    from ai_wall_generator import generate_walls
    from ai_visualizer import visualize_walls

    if not config.geotiff_path:
        raise ValueError("geotiff_path is required for ai_walls stage")

    out_dir = config.stage_dir("ai_walls")
    os.makedirs(out_dir, exist_ok=True)

    # Read modelscale image from stage 2 output dir (not source dir)
    basename = os.path.splitext(os.path.basename(config.geotiff_path))[0]
    modelscale_img = os.path.join(config.mask_full_map_dir, f"{basename}_modelscale.png")
    image_path = modelscale_img if os.path.isfile(modelscale_img) else config.geotiff_path

    mask_path = config.mask_image_path if os.path.isfile(config.mask_image_path) else None

    # Check for trees and grass masks (generated by stage 2)
    trees_mask = config.trees_mask_path if os.path.isfile(config.trees_mask_path) else None
    grass_mask = config.grass_mask_path if os.path.isfile(config.grass_mask_path) else None

    if trees_mask:
        logger.info("Using trees mask: %s", trees_mask)
    else:
        logger.info("No trees mask found, will use color-based detection fallback")
    if grass_mask:
        logger.info("Using grass mask: %s", grass_mask)

    # Generate high-res aerial (2048px) from GeoTIFF for sharper VLM input
    hires_path = os.path.join(out_dir, "hires_aerial_2048.png")
    if not os.path.isfile(hires_path):
        try:
            from geo_tiff_image import GeoTiffImage
            geo = GeoTiffImage(config.geotiff_path)
            hires_img = geo.scale_to_max_size(max_size=2048)
            hires_img.save(hires_path)
            logger.info("Generated high-res aerial (2048px): %s", hires_path)
        except Exception as e:
            logger.warning("Failed to generate high-res aerial (will use modelscale): %s", e)
            hires_path = None
    else:
        logger.info("Using cached high-res aerial: %s", hires_path)

    walls_data = generate_walls(
        image_path=image_path,
        mask_image_path=mask_path,
        trees_mask_path=trees_mask,
        grass_mask_path=grass_mask,
        api_key=config.gemini_api_key,
        model_name=config.gemini_model,
        track_description=config.track_description or None,
        output_dir=out_dir,
        hires_aerial_path=hires_path,
    )

    with open(config.walls_json, "w", encoding="utf-8") as f:
        json.dump(walls_data, f, indent=2, ensure_ascii=False)
    logger.info("Wall JSON saved: %s", config.walls_json)

    try:
        visualize_walls(image_path, walls_data, config.walls_preview)
        logger.info("Wall preview saved: %s", config.walls_preview)
    except Exception as e:
        logger.warning("Wall preview failed (non-critical): %s", e)


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format="[%(asctime)s] %(levelname)s %(name)s: %(message)s")
    p = argparse.ArgumentParser(description="Stage 7: AI wall generation")
    p.add_argument("--geotiff", required=True, help="Path to GeoTIFF image")
    p.add_argument("--output-dir", default="output", help="Output base directory")
    p.add_argument("--gemini-api-key", default="", help="Gemini API key")
    args = p.parse_args()
    config = PipelineConfig(geotiff_path=args.geotiff, output_dir=args.output_dir).resolve()
    if args.gemini_api_key:
        config.gemini_api_key = args.gemini_api_key
    run(config)
